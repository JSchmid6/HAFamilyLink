"""Probe batchCreate with MINUTES-based payloads (unit confirmed from appliedTimeLimits response).

Usage:
    python scripts/probe_batch_array.py <fl_cookies>
"""
from __future__ import annotations

import asyncio
import hashlib
import json
import sys
import time

import aiohttp

FL_COOKIES_FILE = sys.argv[1] if len(sys.argv) > 1 else "fl_cookies.json"

BASE = "https://kidsmanagement-pa.clients6.google.com/kidsmanagement/v1"
API_KEY = "AIzaSyAQb1gupaJhY3CXQy2xmTwJMcjmot3M2hw"
ORIGIN = "https://familylink.google.com"
CHILD_ID = "112452138243419815198"
DEVICE_IDS = {
    "Emilio":  "aannnppah2mzmppd2pzyvz555w3wbq4f4i2qd7qzrpiq",
    "Ronja_1": "aannnppamndo3hpm5l75fc35uyf5efgsiibwjsaexvkq",
    "Ronja_2": "aannnppapjsjabgpoeqyqegjrlhxm44rghua23rzkacq",
    "Lennard": "aannnppanqkemfw6nyffszirutt3aoyltrhqhkkvud3a",
}
EXT_223 = "Ki4KHzIuNzIuMC4yMDI2dzA3LjIwMjYwMjEwLjA0X1JDMDAQCiIJCgdmYW1saW5r"
EXT_202 = "Ci4IAxIqDS+ogbMwBOkYBN/gBATx8RUPnagBD/v+DQSP4QEEz58GBIfGDQ2j6AYO"


def load_cookies(path: str) -> dict[str, str]:
    with open(path, encoding="utf-8") as f:
        return {c["name"]: c["value"] for c in json.load(f)}


def sapisid_hash(sapisid: str) -> str:
    ts = str(int(time.time() * 1000))
    digest = hashlib.sha1(f"{ts} {sapisid} {ORIGIN}".encode()).hexdigest()
    return f"SAPISIDHASH {ts}_{digest}"


def cookie_str(cdict: dict[str, str]) -> str:
    return "; ".join(f"{k}={v}" for k, v in cdict.items())


def make_headers(cookies: dict[str, str]) -> dict[str, str]:
    sapisid = cookies.get("__Secure-3PAPISID") or cookies.get("SAPISID", "")
    return {
        "Authorization": sapisid_hash(sapisid),
        "X-Goog-AuthUser": "0",
        "X-Goog-Api-Key": API_KEY,
        "Content-Type": "application/json+protobuf",
        "Origin": ORIGIN,
        "Referer": f"{ORIGIN}/",
        "Cookie": cookie_str(cookies),
        "x-goog-ext-223261916-bin": EXT_223,
        "x-goog-ext-202964622-bin": EXT_202,
    }


async def probe_batch(
    session: aiohttp.ClientSession,
    cookies: dict,
    device_id: str,
    device_name: str,
    limit_minutes: int,
) -> None:
    url = f"{BASE}/people/{CHILD_ID}/timeLimitOverrides:batchCreate"
    print(f"\n{'='*60}")
    print(f"batchCreate - {device_name} / {limit_minutes} min")

    # SUCCESS: [None, None, 1, device_id] → 200!
    # Response shows generated override ID + 8 more fields, fields [4-7] all null.
    # → field 1 = override_id (id TYPE_STRING, generated by server if null)
    # → int at position 0 fails with "overrides[0].id (TYPE_STRING)" = field1 = STRING id
    # → field 3 = action (1 works)
    # → field 4 = device_id (STRING confirmed)
    # → fields 5-8 = unknown (all null in response → limit not included yet!)
    #
    # NEXT: find where limit_minutes belongs (idx 4, 5, 6, 7?)
    # Action=1 with no limit = LOCK device? Try more specific actions for "set duration".

    limit_secs = limit_minutes * 60
    candidates = {
        # limit at idx4 (field 5)
        "[NA,NA,1,devId,90]":        [None, None, [[None, None, 1, device_id, 90]]],
        "[NA,NA,1,devId,120]":       [None, None, [[None, None, 1, device_id, 120]]],
        "[NA,NA,2,devId,90]":        [None, None, [[None, None, 2, device_id, 90]]],
        "[NA,NA,2,devId,120]":       [None, None, [[None, None, 2, device_id, 120]]],
        # limit in seconds at idx4
        "[NA,NA,1,devId,7200s]":     [None, None, [[None, None, 1, device_id, limit_secs]]],
        "[NA,NA,2,devId,7200s]":     [None, None, [[None, None, 2, device_id, limit_secs]]],
        # limit at idx5 (field 6)
        "[NA,NA,1,devId,NA,90]":     [None, None, [[None, None, 1, device_id, None, 90]]],
        "[NA,NA,1,devId,NA,120]":    [None, None, [[None, None, 1, device_id, None, 120]]],
        "[NA,NA,2,devId,NA,90]":     [None, None, [[None, None, 2, device_id, None, 90]]],
        "[NA,NA,2,devId,NA,120]":    [None, None, [[None, None, 2, device_id, None, 120]]],
        # limit as sub-array at idx4
        "[[90,1],NA,1,devId,NA]":    [None, None, [[[90, 1], None, 1, device_id, None]]],
        "[[120,1],NA,1,devId,NA]":   [None, None, [[[120, 1], None, 1, device_id, None]]],
        # limit at idx6 (field 7)
        "[NA,NA,1,devId,NA,NA,90]":  [None, None, [[None, None, 1, device_id, None, None, 90]]],
        "[NA,NA,2,devId,NA,NA,90]":  [None, None, [[None, None, 2, device_id, None, None, 90]]],
        # action=3 variants
        "[NA,NA,3,devId,90]":        [None, None, [[None, None, 3, device_id, 90]]],
    }

    for label, payload in candidates.items():
        h = make_headers(cookies)
        async with session.post(url, json=payload, headers=h) as r:
            status = r.status
            body = await r.text()
        if status == 200:
            print(f"\n  SUCCESS! [{label}]")
            try:
                parsed = json.loads(body)
                print(json.dumps(parsed, indent=2))
            except Exception:
                print(body[:800])
        elif status == 400:
            try:
                msg = json.loads(body).get("error", {}).get("message", body[:200])
                print(f"  400 [{label}]: {msg[:200]}")
            except Exception:
                print(f"  400 [{label}]: {body[:200]}")
        else:
            print(f"  {status} [{label}]")

    # Also try :batchUpdate
    url_update = f"{BASE}/people/{CHILD_ID}/timeLimitOverrides:batchUpdate"
    print(f"\n--- Trying :batchUpdate ---")
    prio = ["[NA,NA,1,devId,90]", "[NA,NA,2,devId,90]", "[NA,NA,1,devId,120]", "[NA,NA,2,devId,120]"]
    for label, payload in [(k, candidates[k]) for k in prio if k in candidates]:
        h = make_headers(cookies)
        async with session.post(url_update, json=payload, headers=h) as r:
            status = r.status
            body = await r.text()
        if status not in (404,):
            msg = ""
            try:
                msg = json.loads(body).get("error", {}).get("message", "")
            except Exception:
                msg = body[:200]
            print(f"  {status} [{label}]: {msg[:160]}")


async def main() -> None:
    cookies = load_cookies(FL_COOKIES_FILE)
    print(f"Loaded {len(cookies)} cookies")
    jar = aiohttp.CookieJar(unsafe=True)
    async with aiohttp.ClientSession(cookie_jar=jar) as session:
        await probe_batch(session, cookies, DEVICE_IDS["Emilio"], "Emilio", 120)


if __name__ == "__main__":
    asyncio.run(main())